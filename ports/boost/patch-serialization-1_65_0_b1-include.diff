diff --git a/boost/serialization/array.hpp b/boost/serialization/array.hpp
index 61708b3..612d1a6 100644
--- a/boost/serialization/array.hpp
+++ b/boost/serialization/array.hpp
@@ -23,6 +23,8 @@ namespace std{
 } // namespace std
 #endif
 
+#include <boost/serialization/array_wrapper.hpp>
+
 #ifndef BOOST_NO_CXX11_HDR_ARRAY
 
 #include <array>
diff --git a/boost/serialization/binary_object.hpp b/boost/serialization/binary_object.hpp
index 23c734b..5c9038e 100644
--- a/boost/serialization/binary_object.hpp
+++ b/boost/serialization/binary_object.hpp
@@ -55,7 +55,7 @@ struct binary_object :
         m_size = rhs.m_size;
         return *this;
     }
-    binary_object(/* const */ void * const t, std::size_t size) :
+    binary_object(const void * const t, std::size_t size) :
         m_t(t),
         m_size(size)
     {}
@@ -69,7 +69,7 @@ struct binary_object :
 // wrappers follow the naming convention make_xxxxx
 inline 
 const binary_object
-make_binary_object(/* const */ void * t, std::size_t size){
+make_binary_object(const void * t, std::size_t size){
     return binary_object(t, size);
 }
 
diff --git a/boost/serialization/collections_load_imp.hpp b/boost/serialization/collections_load_imp.hpp
index c3b165a..e042c0c 100644
--- a/boost/serialization/collections_load_imp.hpp
+++ b/boost/serialization/collections_load_imp.hpp
@@ -64,7 +64,7 @@ collection_load_impl(
     Archive & ar,
     T & t,
     collection_size_type count,
-    item_version_type
+    item_version_type /*item_version*/
 ){
     t.resize(count);
     typename T::iterator hint;
diff --git a/boost/serialization/detail/is_default_constructible.hpp b/boost/serialization/detail/is_default_constructible.hpp
index 451cca4..4d20b13 100644
--- a/boost/serialization/detail/is_default_constructible.hpp
+++ b/boost/serialization/detail/is_default_constructible.hpp
@@ -18,31 +18,37 @@
 
 #include <boost/config.hpp>
 
-#if defined(_LIBCPP_VERSION) && (_LIBCPP_VERSION >= 1101) \
-|| ! defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
+#if ! defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
     #include <type_traits>
     namespace boost{
     namespace serialization {
     namespace detail {
 
     template<typename T>
-    struct is_default_constructible : std::is_default_constructible<T> {};
+    struct is_default_constructible : public std::is_default_constructible<T> {};
 
     } // detail
     } // serializaition
     } // boost
 #else
+    // we don't have standard library support for is_default_constructible
+    // so we fake it by using boost::has_trivial_construtor.  But this is not
+    // actually correct because it's possible that a default constructor
+    // to be non trivial. So when using this, make sure you're not using your
+    // own definition of of T() but are using the actual default one!
     #include <boost/type_traits/has_trivial_constructor.hpp>
     namespace boost{
     namespace serialization {
     namespace detail {
 
     template<typename T>
-    struct is_default_constructible : boost::has_trivial_constructor<T> {};
+    struct is_default_constructible : public boost::has_trivial_constructor<T> {};
 
     } // detail
     } // serializaition
     } // boost
+
 #endif
 
+
 #endif //  BOOST_SERIALIZATION_DETAIL_IS_DEFAULT_CONSTRUCTIBLE_HPP
diff --git a/boost/serialization/factory.hpp b/boost/serialization/factory.hpp
index db5b1a9..2db7e7e 100644
--- a/boost/serialization/factory.hpp
+++ b/boost/serialization/factory.hpp
@@ -48,32 +48,33 @@ namespace boost {                                         \
 namespace serialization {                                 \
     template<>                                            \
     T * factory<T, N>(std::va_list ap){                   \
-        BOOST_PP_IF(BOOST_PP_GREATER(N,0)                 \
-            ,A0 a0 = va_arg(ap, A0);                      \
-        ,BOOST_PP_IF(BOOST_PP_GREATER(N,1)                \
-            ,A1 a1 = va_arg(ap, A1);                      \
-        ,BOOST_PP_IF(BOOST_PP_GREATER(N,2)                \
-            ,A2 a2 = va_arg(ap, A2);                      \
-        ,BOOST_PP_IF(BOOST_PP_GREATER(N,3)                \
-            ,A3 a3 = va_arg(ap, A3);                      \
-            ,BOOST_PP_EMPTY()                             \
-        ))))                                              \
+        BOOST_PP_IF(BOOST_PP_GREATER(N, 0)                \
+            , A0 a0 = va_arg(ap, A0);, BOOST_PP_EMPTY())  \
+        BOOST_PP_IF(BOOST_PP_GREATER(N, 1)                \
+            , A1 a1 = va_arg(ap, A1);, BOOST_PP_EMPTY())  \
+        BOOST_PP_IF(BOOST_PP_GREATER(N, 2)                \
+            , A2 a2 = va_arg(ap, A2);, BOOST_PP_EMPTY())  \
+        BOOST_PP_IF(BOOST_PP_GREATER(N, 3)                \
+            , A3 a3 = va_arg(ap, A3);, BOOST_PP_EMPTY())  \
         return new T(                                     \
-            BOOST_PP_IF(BOOST_PP_GREATER(N,0)             \
-                ,a0                                       \
-            ,BOOST_PP_IF(BOOST_PP_GREATER(N,1)            \
-                ,a1                                       \
-            ,BOOST_PP_IF(BOOST_PP_GREATER(N,2)            \
-                ,a2                                       \
-            ,BOOST_PP_IF(BOOST_PP_GREATER(N,3)            \
-                ,a3                                       \
-                ,BOOST_PP_EMPTY()                         \
-            ))))                                          \
+            BOOST_PP_IF(BOOST_PP_GREATER(N, 0)            \
+                , a0, BOOST_PP_EMPTY())                   \
+            BOOST_PP_IF(BOOST_PP_GREATER(N, 1))           \
+                , BOOST_PP_COMMA, BOOST_PP_EMPTY)()       \
+            BOOST_PP_IF(BOOST_PP_GREATER(N, 1)            \
+                , a1, BOOST_PP_EMPTY())                   \
+            BOOST_PP_IF(BOOST_PP_GREATER(N, 2))           \
+                , BOOST_PP_COMMA, BOOST_PP_EMPTY)()       \
+            BOOST_PP_IF(BOOST_PP_GREATER(N, 2)            \
+                , a2, BOOST_PP_EMPTY())                   \
+            BOOST_PP_IF(BOOST_PP_GREATER(N, 3))           \
+                , BOOST_PP_COMMA, BOOST_PP_EMPTY)()       \
+            BOOST_PP_IF(BOOST_PP_GREATER(N, 3)            \
+                , a3, BOOST_PP_EMPTY())                   \
         );                                                \
     }                                                     \
 }                                                         \
-}                                                         \
-/**/
+}   /**/
 
 #define BOOST_SERIALIZATION_FACTORY_4(T, A0, A1, A2, A3) \
     BOOST_SERIALIZATION_FACTORY(4, T, A0, A1, A2, A3)
diff --git a/boost/serialization/optional.hpp b/boost/serialization/optional.hpp
index ecd1756..d6ff830 100644
--- a/boost/serialization/optional.hpp
+++ b/boost/serialization/optional.hpp
@@ -29,6 +29,7 @@
 #include <boost/type_traits/is_pointer.hpp>
 #include <boost/serialization/detail/stack_constructor.hpp>
 #include <boost/serialization/detail/is_default_constructible.hpp>
+#include <boost/serialization/force_include.hpp>
 
 // function specializations must be defined in the appropriate
 // namespace - boost::serialization
@@ -46,24 +47,15 @@ void save(
     // default constructor.  It's possible that this could change sometime
     // in the future, but for now, one will have to work around it.  This can
     // be done by serialization the optional<T> as optional<T *>
-    BOOST_STATIC_ASSERT(
-        boost::serialization::detail::is_default_constructible<T>::value
-        || boost::is_pointer<T>::value
-    );
+    #if ! defined(BOOST_NO_CXX11_HDR_TYPE_TRAITS)
+        BOOST_STATIC_ASSERT(
+            boost::serialization::detail::is_default_constructible<T>::value
+            || boost::is_pointer<T>::value
+        );
+    #endif
     const bool tflag = t.is_initialized();
     ar << boost::serialization::make_nvp("initialized", tflag);
     if (tflag){
-        const boost::serialization::item_version_type item_version(version< T >::value);
-        #if 0
-        const boost::archive::library_version_type library_version(
-            ar.get_library_version()
-        };
-        if(boost::archive::library_version_type(3) < library_version){
-            ar << BOOST_SERIALIZATION_NVP(item_version);
-        }
-        #else
-            ar << BOOST_SERIALIZATION_NVP(item_version);
-        #endif
         ar << boost::serialization::make_nvp("value", *t);
     }
 }
@@ -72,7 +64,7 @@ template<class Archive, class T>
 void load(
     Archive & ar, 
     boost::optional< T > & t, 
-    const unsigned int /*version*/
+    const unsigned int version
 ){
     bool tflag;
     ar >> boost::serialization::make_nvp("initialized", tflag);
@@ -81,20 +73,18 @@ void load(
         return;
     }
 
-    boost::serialization::item_version_type item_version(0);
-    boost::archive::library_version_type library_version(
-        ar.get_library_version()
-    );
-    if(boost::archive::library_version_type(3) < library_version){
-        ar >> BOOST_SERIALIZATION_NVP(item_version);
+    if(0 == version){
+        boost::serialization::item_version_type item_version(0);
+        boost::archive::library_version_type library_version(
+            ar.get_library_version()
+        );
+        if(boost::archive::library_version_type(3) < library_version){
+            ar >> BOOST_SERIALIZATION_NVP(item_version);
+        }
     }
-    detail::stack_allocate<T> tp;
-    ar >> boost::serialization::make_nvp("value", tp.reference());
-    t.reset(boost::move(tp.reference()));
-    ar.reset_object_address(
-        t.get_ptr(),
-        & tp.reference()
-    );
+    if(! t.is_initialized())
+        t = T();
+    ar >> boost::serialization::make_nvp("value", *t);
 }
 
 template<class Archive, class T>
@@ -106,7 +96,12 @@ void serialize(
     boost::serialization::split_free(ar, t, version);
 }
 
+template<class T>
+struct version<boost::optional<T> > {
+    BOOST_STATIC_CONSTANT(int, value = 1);
+};
+
 } // serialization
-} // namespace boost
+} // boost
 
 #endif // BOOST_SERIALIZATION_OPTIONAL_HPP_
diff --git a/boost/serialization/singleton.hpp b/boost/serialization/singleton.hpp
index a40488c..b50afed 100644
--- a/boost/serialization/singleton.hpp
+++ b/boost/serialization/singleton.hpp
@@ -81,65 +81,57 @@ namespace serialization {
 // attempt to retieve a mutable instances while locked will
 // generate a assertion if compiled for debug.
 
+// note usage of BOOST_DLLEXPORT.  These functions are in danger of
+// being eliminated by the optimizer when building an application in
+// release mode. Usage of the macro is meant to signal the compiler/linker
+// to avoid dropping these functions which seem to be unreferenced.
+// This usage is not related to autolinking.
+
 class BOOST_SYMBOL_VISIBLE singleton_module :
     public boost::noncopyable
 {
 private:
-    BOOST_SERIALIZATION_DECL static bool & get_lock();
+    BOOST_SERIALIZATION_DECL BOOST_DLLEXPORT static bool & get_lock() BOOST_USED;
 public:
-    static void lock(){
+    BOOST_DLLEXPORT static void lock(){
         get_lock() = true;
     }
-
-    static void unlock(){
+    BOOST_DLLEXPORT static void unlock(){
         get_lock() = false;
     }
-
-    static bool is_locked(){
+    BOOST_DLLEXPORT static bool is_locked(){
         return get_lock();
     }
 };
 
-#include <boost/archive/detail/abi_suffix.hpp> // pops abi_suffix.hpp pragmas
-
-namespace detail {
-
-template<class T>
-class singleton_wrapper : public T
-{
-public:
-    static bool m_is_destroyed;
-    ~singleton_wrapper(){
-        m_is_destroyed = true;
-    }
-};
-
-template<class T>
-bool detail::singleton_wrapper< T >::m_is_destroyed = false;
-
-} // detail
-
-// note usage of BOOST_DLLEXPORT.  These functions are in danger of
-// being eliminated by the optimizer when building an application in
-// release mode. Usage of the macro is meant to signal the compiler/linker
-// to avoid dropping these functions which seem to be unreferenced.
-// This usage is not related to autolinking.
-
 template <class T>
 class singleton : public singleton_module
 {
 private:
-    BOOST_DLLEXPORT static T & instance;
+    static T & m_instance;
     // include this to provoke instantiation at pre-execution time
     static void use(T const *) {}
-    BOOST_DLLEXPORT static T & get_instance() {
-        static detail::singleton_wrapper< T > t;
+    static T & get_instance() {
+        // use a wrapper so that types T with protected constructors
+        // can be used
+        class singleton_wrapper : public T {};
+        static singleton_wrapper t;
         // refer to instance, causing it to be instantiated (and
         // initialized at startup on working compilers)
-        BOOST_ASSERT(! detail::singleton_wrapper< T >::m_is_destroyed);
-        use(& instance);
+        BOOST_ASSERT(! is_destroyed());
+        // note that the following is absolutely essential.
+        // commenting out this statement will cause compilers to fail to
+        // construct the instance at pre-execution time.  This would prevent
+        // our usage/implementation of "locking" and introduce uncertainty into
+        // the sequence of object initializaition.
+        use(& m_instance);
         return static_cast<T &>(t);
     }
+    static bool & get_is_destroyed(){
+        static bool is_destroyed;
+        return is_destroyed;
+    }
+
 public:
     BOOST_DLLEXPORT static T & get_mutable_instance(){
         BOOST_ASSERT(! is_locked());
@@ -149,16 +141,24 @@ public:
         return get_instance();
     }
     BOOST_DLLEXPORT static bool is_destroyed(){
-        return detail::singleton_wrapper< T >::m_is_destroyed;
+        return get_is_destroyed();
+    }
+    BOOST_DLLEXPORT singleton(){
+        get_is_destroyed() = false;
+    }
+    BOOST_DLLEXPORT ~singleton() {
+        get_is_destroyed() = true;
     }
 };
 
 template<class T>
-BOOST_DLLEXPORT T & singleton< T >::instance = singleton< T >::get_instance();
+T & singleton< T >::m_instance = singleton< T >::get_instance();
 
 } // namespace serialization
 } // namespace boost
 
+#include <boost/archive/detail/abi_suffix.hpp> // pops abi_suffix.hpp pragmas
+
 #ifdef BOOST_MSVC
 #pragma warning(pop)
 #endif
